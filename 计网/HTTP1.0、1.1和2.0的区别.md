# HTTP1.0、1.1和2.0的区别

HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。

## 1.0和1.1的区别

- **长连接**，http1.0需要使用keep-live参数告知服务器建立一个连接，http1.1默认支持长连接。http本身是基于TCP/IP协议的，TCP协议提供传输控制，按顺序组织数据，和错误指正。创建一个TCP连接需要三次握手，有一定的开销，每次通讯都需要重新建立连接的话，影响性能。因此最好维持一个长连接发送多个请求，HTTP/1.1持久连接被默认采用，并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度
  - 长链接是指客户端和服务端建立TCP连接后，会持续存在，不会因为一次HTTP请求后关闭，后续的请求也是用这个连接
  - 省去TCP的建立和关闭操作。
- **节约带宽**，http1.1，支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接收到100，才开始把请求body发送到服务器端。当服务器返回401的时候，客户端自然就不用发送body了，节约了带宽。
  另外，http1.1还支持发送内容的一部分。这样当客户端有了一部分资源之后，只需要请求另一部分资源。这也是**断点续传**的基础。
- **HOST域**，http1.1开始支持，webServer上多个虚拟站点可以共享一个ip和端口。WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了==**在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。**==
- **缓存机制**，1.0中使用Expire和Last-Modified/If-Modified-Since。而1.1中使用cache-control和etag/If-None-Match

## 1.1和2.0的区别

- **多路复用**，http2.0实现了(类似epoll)的多路复用技术，==**做到同一个tcp连接可以并发处理多个请求**==，而且并发请求的数量比http1.1大好几个数量级。当然http1.1也可以通过建立多个TCP连接来处理更高的并发请求，但是创建TCP连接本来就有一定的开销。
  ==**TCP建立连接有一个预热和保护的过程，建立连接的初期有慢启动（slow start）的特性，先检查数据是否传送成功，成功后会慢慢加大传输速度，因此应对瞬时的并发TCP连接，服务器压力响应很慢。**==
- **二进制分桢**，HTTP/2在 应用层和传输层(TCP/UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。==**在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码**== ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。
  HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。==**HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。**==
  这种单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；而且由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快。
- **数据压缩**，http1.1不支持header压缩，2.0开始使用HPACK算法对header进行数据压缩，这样数据包的体积变小了，在网络上传输的速度更快。
- **服务器推送**，==**当我们对支持http2.0的web server请求数据的时候，服务器可以对客户端的一个请求发送多个响应。**==服务器会顺便把客户端需要的资源一起推送到客户端，免得重复请求，这种方式非常适合静态资源。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。
