# HTTP缓存机制

## 服务器缓存和客户端缓存
服务端缓存又分为 代理服务器缓存 和 反向代理服务器缓存（也叫网关缓存，比如 Nginx反向代理、Squid等），其实广泛使用的 CDN 也是一种服务端缓存，目的都是让用户的请求走”捷径“，并且都是缓存图片、文件等静态资源。

客户端侧缓存一般指的是浏览器缓存，目的就是加速各种静态资源的访问，想想现在的大型网站，随便一个页面都是一两百个请求，每天 pv 都是亿级别，如果没有缓存，用户体验会急剧下降、同时服务器压力和网络带宽都面临严重的考验。

## 服务器缓存和客户端缓存

服务端缓存又分为 代理服务器缓存 和 反向代理服务器缓存（也叫网关缓存，比如 Nginx反向代理、Squid等），其实广泛使用的 CDN 也是一种服务端缓存，目的都是让用户的请求走”捷径“，并且都是缓存图片、文件等静态资源。

客户端侧缓存一般指的是浏览器缓存，目的就是加速各种静态资源的访问，想想现在的大型网站，随便一个页面都是一两百个请求，每天 pv 都是亿级别，如果没有缓存，用户体验会急剧下降、同时服务器压力和网络带宽都面临严重的考验。

## 缓存机制

有两种缓存机制，**强制缓存**和**对比缓存**

## 强制缓存

对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）

**Expires**
　　Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。
不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。
另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。
所以HTTP 1.1 的版本，使用Cache-Control替代。

**Cache-Control**
Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。
private:        客户端可以缓存
public:         客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
max-age=xxx:  缓存的内容将在 xxx 秒后失效
no-cache:      需要使用对比缓存来验证缓存数据（后面介绍）
no-store:       所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so...基本上和它说886）

## 对比缓存

对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。
浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。
再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

**Last-Modified / If-Modified-Since**
**Last-Modified：**
服务器在响应请求时，告诉浏览器资源的最后修改时间。
![img](https://gitee.com/super-jimwang/img/raw/master/img/20210214223329.png)
**If-Modified-Since：**
再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。
服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。
若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；
若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。

![img](https://gitee.com/super-jimwang/img/raw/master/img/20210214223355.png)

**Etag / If-None-Match**（优先级高于Last-Modified / If-Modified-Since）
**Etag：**
服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

![img](https://gitee.com/super-jimwang/img/raw/master/img/20210214223400.png)
**If-None-Match：**
再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。
服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，
不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；
相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。

![img](https://gitee.com/super-jimwang/img/raw/master/img/20210214223403.png)

## 缓存与用户行为的关系

浏览器缓存过程还和用户行为有关。譬如先打开一个主页有个jquery的请求（假设访问后会缓存下来）。

接着如果直接在地址栏输入 jquery 地址，然后回车，响应HTTP200（from cache），因为有效期还没过直接读取的缓存；如果`ctrl+r`进行刷新，则会相应HTTP304（Not Modified），虽然还是读取的本地缓存，但是多了一次服务端的请求；而如果是ctrl+shift+r强刷，则会直接从服务器下载新的文件，响应HTTP200。



==**注意：POST请求无法被缓存**==


## HTTP1.0和HTTP1.1中的缓存处理

在HTTP/1.0协议中，Last-Modified（对比缓存）是控制缓存的一个非常重要的HTTP头。如果需要控制浏览器的缓存，服务器首先必须发送一个 以UTC时间为值的Last-Modifeid头，当第二次访问这个页面时，浏览器会发送一个If-Modified-Since头给服务器，让服务器判 断是否有必要更新内容，这个If-Modified-Since头的值就是上次访问页面时，浏览器发送的Last-Modifeid头的值。

Expires（强制缓存）是HTTP/1.0中另外一个很重要的HTTP头，它表示缓存的存在时间，告诉客户端浏览器在这个时间之前不对服务器发送请求，而直接使用浏览器的缓存。

在HTTP1.1中，通过`cache-control:`来控制缓存策略