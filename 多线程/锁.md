# 锁

> 说一下synchronized的优化，锁的升级路线

引入了多个锁，无锁->偏向锁->轻量级锁->重量级锁

还有自旋锁

偏向锁：只有一个线程用对象锁的时候
轻量级锁：多个线程使用，但是不会发生竞争，在不同时候使用
重量级锁：多个线程发生竞争

> 讲一下偏向锁是怎么回事，获取锁的过程

主要用在没有多线程竞争的前提下，减少使用操作系统互斥量的性能消耗。无需CAS

当一个线程访问同步块并获取锁时，会在锁对象的对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时，都不需要CAS操作。

如果MarkWord里存的线程ID不是当前线程的ID。测试以下MarkWord中偏向锁的表标示是否为1，如果没有，则使用CAS竞争锁，如果设置了，就用CAS将偏向指向自己。（升级为轻量级锁）

> 讲一下偏向锁为什么会被撤销，怎么撤销

1. 发生竞争，多个线程使用的时候
2. 调用.hashcode的时候，因为对象头用来存hashcode了，没地方存偏向信息

首先会暂停持有偏向锁的进程，然后检查持有偏向锁的线程是否存活，如果不处于活动状态，则将锁对象的对象头设置为无锁状态；如果线程存活，则将对象的对象头中MarkWord和栈中的锁记录恢复，然后要么重新指向别的线程，要么恢复到无锁状态。然后唤醒暂停的线程（释放偏向锁的线程）

> 讲一下轻量级锁是怎么加锁的

拷贝对象头中的Mark Word复制到锁记录（Lock Record）中

==拷贝成功后，虚拟机将使用CAS操作尝试将锁对象的Mark Word更新为指向Lock Record的指针，并将线程栈帧中的Lock Record里的owner指针指向Object的 Mark Word。==

如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态

如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

![image-20200528140916607](https://gitee.com/super-jimwang/img/raw/master/img/20210403171843.png)

> 讲一下锁膨胀

在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

==对象的mark word不再指向lock record，而是指向monitor，另外monitor中的owner指向该线程的lock record==
![image-20200528142540567](https://gitee.com/super-jimwang/img/raw/master/img/20210308194253.png)


> 自旋锁是什么，为什么要用它

自旋锁就是让线程执行一个忙循环，而不进入挂起状态。

因为一般线程持有锁的时间都不是太长，所以仅仅为了这点时间而区挂起线程/恢复线程需要消耗资源（用户态切换到内核态）

> 自旋锁会一直循环下去吗？为什么会这样

不会，默认的次数是10次。如果一直循环下去会占用cpu

> 重量级锁怎么加锁

![](https://gitee.com/super-jimwang/img/raw/master/img/20210302144618.png)
当多个线程同时访问一段同步代码时，首先会进入 Entry Set 竞争获取对象的monitor（锁）

当线程A获取到对象的monitor 后进入 The Owner 区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1

若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒

若线程调用 notify()/notifyAll() 方式时，将释放当前持有的monitor并复位变量，同时唤醒 WaitSet 中的等待线程（notify随机通知一个线程，notifyAll通知所有线程）重新竞争monitor

若线程执行完毕也将释放monitor并复位变量，以便其他线程获取monitor

> 为什么重量级锁性能差

监视器锁依赖底层操作系统的mutex lock互斥锁实现的。他需要唤醒和阻塞线程，这需要用户态切换到内核态，所以成本较高。

> volatile如何保证可见性和有序性？

可见性

写屏障能够保证该屏障之前的，对共享变量的变动存到主存中

读屏障能够保证该屏障之后的变量，都是主存中读取过来的。


有序性
- 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
- 读屏障会确保重排序时，不会将读屏障之前的代码排在读屏障之后

> Synchronized如何保证可见性

JMM中关于synchronized有如下规定，线程加锁时，必须清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取；线程在解锁时，需要把工作内存中最新的共享变量的值写入到主存，以此来保证共享变量的可见性

> Synchronized如何保证有序性

由于被Synchronzied修饰的代码块同一时间只能一个线程访问，单线程是有序执行的。所以可以保证有序性。as-if-serial语义，单线程不管怎么样重排，其执行结果不变

> 双重检验的单例模式有了synchronized，为什么还需要volatile

因为synchronized只能保证有序性，而==不能保证指令重排。==

new对象的过程：
- new对象
- 初始化
- 引用指向对象

如果重排了，还未初始化的对象被引用了，而另一个线程过来直接拿走了这个单例对象去使用就会用问题。而volatile可以保证不被指令重排序。保证new对象的三步全部执行完了之后，后面的指令才能执行。

> volatile如何保证不被指令重排序

volatile写之前有一个storestore屏障，禁止之前的普通写与valatile写重排序。volatile写之后有一个storeload屏障，防止volatile写与之后可能的volatile写/读重排序

volatile读之后有一个loadload屏障，防止之后的普通读与volatile读指令重排。在loadload屏障后有一个loadstore屏障，防止之后的普通写与volatile读屏障重排。

![](https://gitee.com/super-jimwang/img/raw/master/img/20210309204249.png)

> volatile如何同步数据？多处理器的总线嗅探是什么？

1.当写一个volatile变量时，JMM（java共享内存模型）会把该线程对应的本地内存中的共享变量值刷新到主内存；

2.当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来从主内存中读取共享变量。

在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。

处理器使用嗅探技术保证它的内部缓存，系统内存和其他处理器的缓存在总线上保持一致