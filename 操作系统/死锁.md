# 死锁

## 什么是死锁

在并发环境下，各进程竞争资源而造成的一种相互等待对方手里资源，导致各个进程都阻塞，都无法向前推进的现象，就是死锁



## 死锁的必要条件

- 互斥条件：对必须互斥访问的资源的争抢才会导致死锁
- 不可剥夺条件：进程所获的的资源没有使用完之前，不能由其他进程强行夺走，只能主动释放
- 循环等待条件：存在循环等待链，链上的每一个进程已经获得的资源被下一个进程请求。
- 占有且等待条件：进程已经获取了一项资源，但是又提出了其他请求，此时请求被阻塞，但又对自己的资源保持不放。



## 死锁的处理策略

### 预防死锁

破坏死锁的四个必要条件中的一个或几个



**破坏互斥条件**：把互斥的资源改造成共享使用，则系统不会进入死锁状态。比如**SPOOLing技术**，把独占设备改造成共享设备。在使用之后，各个请求被处理，进程不需要阻塞等待。

缺点：但并不是所有的资源都可以使用这一项技术改造成共享资源



**破坏不可剥夺条件：**方式一：当某一个进程请求的资源得不到满足的时候，立即释放保持的所有条件，待以后需要的时候在申请。方式二：当进程需要的资源被其他进程所占有的时候，由操作系统协助把需要的资源剥夺（涉及优先级）。

缺点：复杂、反复申请释放资源增加开销，可能使以前的一些工作失效。因此这种方法只适用于易保存易恢复状态的资源。



**破坏占有且等待条件**：采用静态分配法，进程运行前一次性申请完它所需要的所有资源。

缺点：资源利用率低，可能会导致饥饿。



**破坏循环等待条件：**顺序资源分配法。给系统中的资源编号，规定进程按照递增的顺序请求资源。一个进程已经占有小编号资源才有资格申请大编号资源。

缺点：不方便新增资源，进程使用资源的顺序可能不是递增的。会导致资源浪费





### 避免死锁

用某种方法防止系统进入不安全状态，如银行家算法。

**安全序列**，指系统按照一个序列分配资源，每个进程都能顺利的完成。安全序列可以有很多个。



如果系统找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有的进程都无法继续进行下去。当然如果一些进程归还了一些资源，系统可能也有可能重新回到安全状态，不过我们要考虑最坏的情况。



处于安全状态，一定不会死锁；处于不安全状态，就可能发生死锁。因此在资源分配之前预先判断这次分配是否会导致系统进入不安全状态。**未雨绸缪，这也是银行家算法的核心思想**

![image-20210206162153879](https://gitee.com/super-jimwang/img/raw/master/img/20210206162153.png)

> 银行家算法

1. 检查手上资源够不够一个进程完成
   1. 不够就不安全
2. 若分配了，是否能满足一个进程的需求
   1. 不能则不安全
3. 分配给一个进程之后，进程原有的资源也能一起释放出来
4. 继续重复2，3.如果能这么一种分配顺序所有进程都能安全执行完，就安全。

### 死锁的检测和解除

允许死锁发生，不过操作系统会检测死锁的发生，然后才去某种措施解决。