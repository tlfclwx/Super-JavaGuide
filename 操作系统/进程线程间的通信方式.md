# 进程线程间的通信方式

## 为什么进程间需要通信

进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。

**进程间通信的目的：**

- 数据传输：一个进程需要将它的数据发送给另一个进程。
- 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
- 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。
- 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。



## 进程间通信的方式

### 管道

管道包括三种:

- 普通管道PIPE：      通常有两种限制,一是单工==（只能一个方向传输）==,只能单向传输;二是只能在父子或者兄弟进程间使用.
- 流管道s_pipe:       去除了第一种限制,为半双工==（可以两个方向传输，但是不能同时传输）==，只能在父子或兄弟进程间使用，可以双向传输.
- 命名管道:name_pipe：去除了第二种限制,可以在许多**并不相关的进程**之间进行通讯.



常见的linux命令“|“是匿名管道，普通管道的一种。单工，并且只能在父子或者兄弟进程间使用。

通过mkfifo可以创建命名管道。

```
mkfifo pipe
打开两个终端
shell1 : echo 'golang' > pipe
shell2 : cat < pipe
```

但是这个是==半双工==，不能同时两个方向传输的。



管道都是将数据写了在内核中的缓存，读取也需要通过内核。另外==遵循先进先出原则==。



### 信号量

- 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。
- 它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。
- 因此，主要作为进程间以及同一进程内不同线程之间的同步手段。



**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 **P 操作和 V 操作**。



### 消息队列

- 消息队列是由消息的链表，存放在==内核==中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。

使用消息队列进行进程间通信，可能会受到数据块最大长度的限制约束等，消息队列通信的速度不是最及时的，毕竟**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程**。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。

  **1、消息队列的特点**

  **(1)消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.
  (2)==消息队列允许一个或多个进程向它写入与读取消息.==
  (3)管道和命名管道都是通信数据都是先进先出的原则。
  (4)==消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。==**



### 信号

信号是进程间通信机制中**唯一的异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。



### 共享内存

共享内存这个通信方式就可以很好着解决拷贝所消耗的时间了。==系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中==，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有**最快**的进程间通信方式之名。但是便捷高效的共享内存通信，**带来新的问题，==多进程竞争同个共享资源会造成数据的错乱==。**

如何解决进程竞争问题？ ==进程互斥==

### 套接字( socket ) 

如果**要与不同主机的进程间通信，那么就需要 Socket 通信了**。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，==一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式==。



## 线程间通信方法

同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：



- 互斥的方式，可保证任意时刻只有一个线程访问共享资源；
- 同步的方式，可保证线程 A 应在线程 B 之前执行；



1. volatile
2. 等待/通知机制
3. join方式
4. threadLocal
   