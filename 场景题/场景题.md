# 场景题
> 大数据情况下求去最大的top K个

1. 局部淘汰，使用冒泡排序
   - 每一轮排序能获得最大的那一个，所以经过K轮就可以获得topK
   - 时间复杂度 O(KN)，空间复杂度 O(K)
2. 使用堆来实现
    - 用小顶堆，堆顶是最小值。那么新来一个数据，如果小于堆顶，那么就直接抛弃。否则插入堆中
    - 时间复杂度O(NlogK)，空间复杂度O(K)
3. 归并
   - 把大数据分成N份，每一份内求topK。然后用快排的思想，找到正好为K的那个元素，那么左边的就是答案了。

> 数据库分表分库后，如何保证所有数据库的id唯一且自增？

- 这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。
- 可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。

![](https://gitee.com/super-jimwang/img/raw/master/img/20210320080312.png)

> 100万数据，四个节点同时操作怎么做

- 分段，每个节点按照id分到25w个数据。

> 三门问题

一共三个门，一个门后面有汽车，其他两个是空的。你先选了一个，主持人帮你在另外两个里排除了一个，这时候你有一次换的机会，你换不换，为什么，概率是多少？

==换。看下面解析，总结来说就是你一开始选的是1/3，而另外的2/3，此时主持人帮你排除了一个，那么剩下的那一个就占了2/3的概率。比手头的1/3高。==

游戏1.有三个盒子，一个盒子里有钻石，其它两个什么都没有。你先选了一个盒子，放在你的书包里。主持人把另外两个放在他的书包里。这时候问你，要不要用你的书包换主持人的书包？

分析：你的书包只有一个盒子，主持人的书包有两个，很显然，主持人的书包里有钻石的可能性更大。所以应该选择换！

游戏2.有三个盒子，一个盒子里有钻石，其它两个什么都没有。你先选了一个盒子，放在你的书包里。主持人把另外两个放在他的书包里。然后主持人从他的书包里扔掉一个没有钻石的盒子。这时候问你，要不要用你的书包换主持人的书包？

分析：主持人从他的书包里扔掉一个没有钻石的盒子，这个行为并不会改变书包里有钻石的概率。所以既然游戏1要换，那么游戏2同样要换。

游戏3.有三个盒子，一个盒子里有钻石，其它两个什么都没有。你先选了一个盒子。然后主持人从另外两个盒子中扔掉一个没有钻石的盒子。这时候问你，要不要用你的盒子换剩下的那个盒子？

分析：游戏2相对于游戏3，唯一的不同是增加了“书包”这个概念，但其实有没有把盒子装入书包，并不会对结论产生影响，本质上游戏3和游戏2是同一个游戏。所以游戏3同样要换。

> 软件工程开发的一个流程

- 需求分析
- 确认需求（包括精确到多少秒的延迟，能同时被多少流量访问等）
- 架构师进行架构
- 项目开发
- 测试

> 让你设计一个项目，从顶层出发你会怎么设计

- 安全
- 高可用
- 高并发
- 可拓展
- 灵活（可以应用到不同场景）

> 两个1亿行的文件求交集。

分治+hash

将a，b两个文件通过hash分成1000个文件。每次读入相同hash的a，b子文件，求交集。

> 1亿行的数字排序

分治

将1亿行分成1000个文件。每个文件内排序，然后每个文件维护一个指针，每次读一个，比较，选最小的加入，该文件的指针+1。

> 大文件中返回频数最高的100个词

此处1G文件远远大于1M内存，分治法，先hash映射把大文件分成很多个小文件，具体操作如下：读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件(记为f0,f1,...,f4999)中，这样每个文件大概是200k左右（每个相同的词一定被映射到了同一文件中）

（2）对于每个文件fi，都用hash_map做词和出现频率的统计，取出频率大的前100个词（怎么取？topK问题，建立一个100个节点的最小堆），把这100个词和出现频率再单独存入一个文件
==这里为什么每个文件选前100个是没问题的，因为hash会把相同的词一定放到一个文件中==

（3）根据上述处理，我们又得到了5000个文件，归并文件取出top100

> 数据类，两个方法插入数据，复杂度O(lgN)，查找，复杂度是O(1)。如何实现

- 最大堆和最小堆，维护两个堆堆大小平衡，差距不超过1。最大堆存较小的一半，最小堆存较大的一半。取中位数的时候，取两个堆的堆顶。

>  50亿个Integer数，2G内存，快速查找50亿个数的中位数。

- 每个数4字节，2G能存5亿个。
- 分组，每个组内按照最大基数，分布桶。
- 然后每组都从0号桶开始，拿出数据，当累加到25亿的时候，所有分组的那个桶里都可能存了中位数。因此把问题转换到从这些桶内找中位数。可以继续这个方法。直到只剩一个数。

>  一只狐狸在追一只鸭子，鸭子逃到了一个正圆形池塘的圆心O位置，狐狸不会游泳，鸭子也不能在水面上起飞，狐狸奔跑的速度是鸭子游泳速度的4倍。假设鸭子和狐狸分别遵循着最优的逃跑和追逐策略，请问：鸭子能不能安全地游到池塘边并起飞？如果能，如何才能做到？


解：设圆的半径是R，由已知鸭子的速度是V，狐狸的速度是4V，可以得知，当鸭子在距离圆心R/4之内（图中深色部分）围绕圆心做圆周运动时，角速度要大于狐狸。我们暂且假定它就在一个半径为R/4的小圆上围绕圆心游走，只要经过一段时间追赶，鸭子一定会游到这样一个位置，它在图中N点，狐狸在M点，既它和狐狸在同一条直径上，但位置在圆心的两边。

此时鸭子立即改为沿半径方向往岸边P点游，显然，它离岸边的距离为3R/4，它登岸需要的时间是3R/4V；而狐狸到P点的距离正好是半圆，即Rπ，狐狸需要的时间是Rπ/4V。因为π=3.14>3，所以 鸭子先上岸，飞了。

> 用一个mutex(mutex.lock(), mutex.unlock())，实现10个线程安全并发访问一个长度一亿的数组。每个线程会随机修改数组中的某个索引位置；

> 设计朋友圈，查朋友圈的接口怎么设计

参数：用户id，可见的好友id列表

1. 从缓存中取上一次进入朋友圈时，好友最迟的动态时间
2. 取所有好友，获取动态时间>=上次的
3. 将不可见的做删除
4. 按照时间排序返回