# 什么是索引以及索引的分类
## 什么是索引
索引是对数据库表中一个或多个列的值进行**排序**的数据结构，以协助快速查询、更新数据库表中数据。

## 索引的底层结构
底层数据结构是B+树。

在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。

## 索引的分类
唯一索引：唯一索引不允许两行具有相同的索引值。

主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空。

聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个。**innodb中的b+树就是，将索引和数据保存在同一个b+树中**

非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个。**在innodb中的b+树就是索引和数据不保存在一起**

## 索引的优缺点
（1）优点：
- 大大加快数据的检索速度，这也是创建索引的最主要的原因；
- 加速表和表之间的连接；
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；

（2）缺点：
- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；
- 空间方面：索引需要占物理空间。

## 什么样的字段适合创建索引
- 经常作查询选择的字段
- 经常作表连接的字段
- 经常出现在order by, group by, distinct后面的字段

## 索引那么好用为什么不每列都加索引

第一，创建索引和维护索引要耗费时间，这种时间随着数据 量的增加而增加。

第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

> 什么是索引覆盖和回表操作，如何避免回表

比如说你建立了一个A，B联合索引，你的sql语句是 select A，B from table where A=xxx你会发现你想要搜索的A，B从索引数据中已经存在了，压根不用拿到id到表数据中去查找，此时便不会回表，这种现象就叫做索引覆盖。 ==因为A，B就存在了innodb的辅助索引中，直接用就行了，不必根据主键再去主索引的B+树找==

现在你把语句改为了 select A，B，C from table where A=xxx, B=xxx，C毕竟不在索引数据中，拿不到，那只能先拿到id再去主键索引中找，此时就是回表。

避免回表：

用主键搜索
只查询被联合索引覆盖的字段

> 什么是mysql的哈希索引，讲一下缺点

哈希索引只包含哈希值和行指针，而不存储字段值

哈希索引数据并不是按照索引列的值顺序存储的，所以也就无法用于排序

哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引的全部列值内容来计算哈希值的。如：数据列（a,b）上建立哈希索引，如果只查询数据列a，则无法使用该索引。

哈希索引只支持等值比较查询，如：=,in(),<=>(注意，<>和<=>是不同的操作)，不支持任何范围查询（必须给定具体的where条件值来计算hash值，所以不支持范围查询）

> 什么是mysql缓存，什么时候会失效

查询前会先去缓存看看有没有，没有再去查数据库，并且更新缓存。

缓存建立之后，mysql的查询缓存系统会跟踪查询中涉及的每张表，如果表发生变化，那么和这张表相关的缓存将失效

> b+索引树一般多高，高度怎么计算？

一般来说b+树的高度维持在3左右。logB(N)。B为b+树的阶数，也就是一个节点可以存多少索引。