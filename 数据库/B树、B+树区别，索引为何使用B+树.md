# B树、B+树区别，索引为何使用B+树
## B树
描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。

一颗m阶的B树定义如下：
1）每个结点最多有m-1个关键字。
2）根结点最少可以只有1个关键字。
3）非根结点至少有Math.ceil(m/2)-1个关键字。
4）每个结点中的关键字都按照从小到大的顺序排列，**每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。**
5）所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。

下图为**4阶B树**：
![](https://gitee.com/super-jimwang/img/raw/master/img/20210221172547.png)

一个节点可以最多保存3个(4-1)数据.并且非根节点，每个节点至少要有3/2向上取整-1个数据。

## B+树
1. 有n个子节点的非叶子结点中**含有n个关键字（b树是n-1个），这里不同地方的说法不同，也可能是n-1个。与B树保持一致**，这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）;
2. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接;
3. 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字;
4. **通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点;**
5. 同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。

![](https://gitee.com/super-jimwang/img/raw/master/img/20210221173550.png)

## 索引为什么用B+树，而不是B树
B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。

**B+ 树的优点在于：**

**IO次数更少**：由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此**访问叶子节点上关联的数据也具有更好的缓存命中率。**

遍历更加方便：B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。


**B树的优点**
- 由于节点就存了数据，所以不需要访问到叶子节点，访问更迅速。

### 原因
1、 ==**B+树的磁盘读写代价更低**==：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，==那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。==

2、==**B+树的查询效率更加稳定**==：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。==所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。==

3、==**B+树更便于遍历**==：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。==**数据都在叶子节点，叶子节点又有额外的指针相连，所以区间查询以及遍历更容易**==

4、==B+树更适合基于范围的查询==：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

> 如何根据索引找到一个记录

通过根节点开始遍历一个索引的B+树，通过各层非叶子节点达到底层的叶子节点的数据页（Page），这个Page内部存放的都是叶子节点
在Page内部从“Infimum”节点开始遍历单链表（遍历一般会被优化），如果找到键则返回。如果遍历到了“Supremum”，说明当前Page里没有合适的键，这时借助Page页内部的next page指针，跳转到下一个page继续从“Infmum”开始逐个查找